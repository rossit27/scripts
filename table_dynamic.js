// This is a function that will generate an html table and display it on a webpage
// It takes a JSON response object and an array containing the column headers as input params and outputs the table

// Checks if the property is empty and ensures that the properties are not numbers
// The reason I do this is b/c when I try to access sub-props to see if I need to go deeper,
// sometimes bracket notation gets the index of a character in a string object -_-

// Also make sure to put a HTML element on the page so the table generated gets put in it

// This script does this:
// 1. Takes a JSON object (res) and an array that has the table headers in order (table_headers)
// 2. Sets all of the values in the object to an array containing the values for the array
// 3. Parses through the array and adds the values to the table. The order is not defined, and there's currently no way to do that. That's a WIP.
//  3.1 - Also skips the specified keys in the array (like, you don't want to show people the _id field, do you?
// 4. Attaches everything to an HTML table and returns is
function isEmptyObject(obj) {
    for(var prop in obj) {
        if (!isNaN(prop)) {
            return true;
        }
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
        }
    }
    return true;
}

function json_res_to_table(res, table_headers) {
	// First create the table elements
	console.log('function called');
    console.log(res[1].capital);
	var table = document.createElement("table");

	// The classes are Bootstrap classes because there's no way I'm writing that css myself
	table.classList.add("table-condensed");
	table.classList.add("table");
	table.classList.add("table-striped");
	table.classList.add("table-hover");

	// Add the headers to the table
	var headers = [];
	var headerRow = document.createElement("tr");
	var thead = document.createElement("thead");
	for (var h=0; h<table_headers.length; h++) {
		headers[h] = document.createElement("th");
		headers[h].appendChild(document.createTextNode(table_headers[h]));
		headerRow.appendChild(headers[h]);
	}
	thead.appendChild(headerRow);
	table.appendChild(thead);

	var tbody = document.createElement("tbody");

	// Add the values into the columns
	// Watch out for M.N. - using 0 because it's most likey got data representitive of the rest of the set in it
	for (var e=0; e<res.length; ++e) {
		var tr = document.createElement("tr");
		var td = [];
		var keys = [];
		var n = 0;

        // Loop through the data, and if there are any sub-properties, bring em' up
        var toRemove;
        for (var key in res[e]) {
            if (!isEmptyObject(res[e][key])) {
                for (var k in res[e][key]) {
                    console.log(k);
                    toRemove = key;
                    res[e][k] = res[e][key][k];
                }
            }
        }
        // Remove the old property
        delete res[0][toRemove];

		// Only use the data the the columns that will be labelled
		for (var key in res[0]) {
            // If the id is and _id that gets generated by Mongo, skip it. Also the __v field in mongoose. Also "id" field, none of those (something to do with toObject and toJSON on the models)
            if (key == "_id" || key == "__v" || key == "id") {
                continue;
            }
			if (n < table_headers.length) {
				keys[n] = key;
				n++;
			}
			else {
				break;
			}
		}

		// Loop thru and append all the data for the columns
		for (var u=0; u<keys.length; u++) {
            console.log(keys[u]);
            console.log(res[e][keys[u]]);
			var te = 0;
			td[te] = document.createElement("td");
			td[te].appendChild(document.createTextNode((res[e][keys[u]])));
			tr.appendChild(td[te]);
		}

		// Append the values to the table
		tbody.appendChild(tr);
	}
	table.appendChild(tbody);
	return table;
}
